<!DOCTYPE html>
<meta charset="utf-8">
<style>

.land {
  fill: white;
  fill-opacity:0;
  stroke: #222;
}

.circle-station {
  fill:white;
  stroke:rgba(82, 82, 82, 1);
  stroke-linejoin: round;
  stroke-linecap: round;
  stroke-width: 1;
}

</style>
<body>
<script src="//d3js.org/d3.v3.min.js"></script>
<script src="//d3js.org/d3.geo.projection.v0.min.js"></script>
<script src="conrec.js"></script>
<script src="kriging.js"></script>
<script src="data.js"></script>
<script>

var width = 960,
    height = 700;

var projection = d3.geo.mercator()
    .scale((1 << 14) / 2 / Math.PI)
    .translate([width / 2, height / 2])
    .precision(.1)
    .center([1.65, 46.5])

var path = d3.geo.path()
    .projection(projection);


var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var tile = svg.append('g');
var country = svg.append('g')
var points = svg.append('g');

var colorRamp = ["#6363FF", "#6373FF", "#63A3FF", "#63E3FF", "#63FFFB", "#63FFCB",
               "#63FF9B", "#63FF6B", "#7BFF63", "#BBFF63", "#DBFF63", "#FBFF63",
               "#FFD363", "#FFB363", "#FF8363", "#FF7363", "#FF6364"]

var colours = d3.scale.quantize()
  .domain([-5,10])
  .range(colorRamp);

d3.json("FRA.geo.json", function(error, france) {
  if (error) throw error;

  d3.json('data.json',function(error,data){
    if (error) throw error;

          // number of cells on the x (width) and the y (height) axis
          var nx = 30;
          var ny = 15;

          var Grid = [];
          for (ix = 0;ix<=nx;ix++){
            for(iy = 0;iy<=ny;iy++){
              var xy = [width/nx*ix,height/ny*iy]
              Grid.push({'g':[ix,iy],'s':xy,'c':projection.invert(xy),'v':null})
            }
          }

          var model = "gaussian";
          var sigma2 = 1, alpha = 100;
          var kz = data.features.map(function(x){return x.properties.value})
          var kx = data.features.map(function(x){return projection(x.geometry.coordinates)[0]})
          var ky = data.features.map(function(x){return projection(x.geometry.coordinates)[1]})
          //console.log(kx)
          //console.log(ky)
          //console.log(kz)

          var fitModel = kriging.train(kz, kx, ky, model, sigma2, alpha);
          data.features.forEach(function(x){
            var pr = projection(x.geometry.coordinates)
            var kp = kriging.predict(pr[0], pr[1], fitModel);
            console.log([x.properties.value,kp])

          })

          Grid.forEach(function(x){
            return x.v = kriging.predict(x.s[0], x.s[1], fitModel);
          })
          //console.log(Grid)

          var GridFlat = Array.apply(null, Array(nx+1)).map(function(){
            return Array.apply(null, Array(ny+1)).map(function(){
              return null
            })
          })


          Grid.forEach(function(x){
            GridFlat[x['g'][0]][x['g'][1]] = x['v'];
          })
          console.log([GridFlat.length,GridFlat[0].length])
          console.log(GridFlat)
          var cliff = -1000;
          GridFlat.push(d3.range(GridFlat[0].length).map(function() { return cliff; }));
          GridFlat.unshift(d3.range(GridFlat[0].length).map(function() { return cliff; }));
          GridFlat.forEach(function(d) {
            d.push(cliff);
            d.unshift(cliff);
          });

          //console.log(GridFlat)
          var c = new Conrec,
              xs = d3.range(0, GridFlat.length),
              ys = d3.range(0, GridFlat[0].length),
              zs = d3.range(0,15,1),
              xscale = d3.scale.linear().range([0, width]).domain([0, GridFlat.length]),
              yscale = d3.scale.linear().range([0, height]).domain([0, GridFlat[0].length])
          c.contour(GridFlat, 0, xs.length-1, 0, ys.length-1, xs, ys, zs.length, zs);
          //console.log(xs)
          //console.log(ys)
          //console.log(c.contourList())

          tile
              .attr("width", width)
              .attr("height", height)
            .selectAll("path")
              .data(c.contourList())
            .enter().append("path")
              .style("fill",function(d) {
                console.log(d.level)
                return colours(d.level);})
              .attr("d", d3.svg.line()
                .x(function(d) {
                  //console.log(xscale(d.x))
                  return xscale(d.x); })
                .y(function(d) { return yscale(d.y); }));

                console.log(data)
                points.selectAll('g')
                .data(data.features)
                .enter()
                .append('circle')
                .attr('class','circle-station')
                .attr("cx", function(d) {
                  var c = d.geometry.coordinates
                  return projection(c)[0];
                })
                .attr("cy", function(d) {
                  var c = d.geometry.coordinates
                  return projection(c)[1];
                })
                .attr('r',4)
                .style('fill',function(d){
                  //console.log(d.properties.value)
                  return colours(d.properties.value)
                })


  })


    country.insert("path", ".graticule")
        .datum(france)
        .attr("class", "land")
        .attr("d", path);


});

d3.select(self.frameElement).style("height", height + "px");

</script>
